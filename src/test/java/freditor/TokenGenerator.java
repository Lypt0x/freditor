package freditor;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.Map;

public class TokenGenerator {
    public static void main(String[] args) {
        new TokenGenerator().generateTokens(
                "else", "false", "if", "repeat", "true", "void", "while",
                "!", "&&", "(", ")", ";", "{", "||", "}"
        );
    }

    private int negative = -6;
    private int positive = 7;

    private String entries = "";
    private final LinkedHashMap<String, String> transitions = new LinkedHashMap<>();

    private void autoGenerated() {
        System.out.println("\n// auto-generated by " + getClass().getName());
    }

    private void generateTokens(String... tokens) {
        computeTransitions(tokens);

        autoGenerated();
        generateStates();

        autoGenerated();
        generateEntryCases();

        autoGenerated();
        generateTransitionCases(true, "keyword", "identifier(input)");
        generateTransitionCases(false, "operator", "END");
    }

    private void computeTransitions(String[] tokens) {
        for (String token : tokens) {
            computeFirstTransition(token);
            computeNextTransitions(token);
        }
    }

    private void computeFirstTransition(String token) {
        char input = token.charAt(0);
        if (entries.indexOf(input) < 0) {
            entries += input;
            transitions.put(String.valueOf(input), "");
        }
    }

    private void computeNextTransitions(String token) {
        String prefix = token.substring(0, 1);
        final int len = token.length();
        for (int i = 1; i < len; ++i) {
            String inputs = transitions.get(prefix);
            char input = token.charAt(i);
            if (inputs.indexOf(input) < 0) {
                transitions.put(prefix, inputs + input);
                prefix = token.substring(0, i + 1);
                transitions.put(prefix, "");
            } else {
                prefix = token.substring(0, i + 1);
            }
        }
    }

    private void generateStates() {
        for (String prefix : transitions.keySet()) {
            if (prefix.length() == 1) {
                System.out.println("public static final int " + stateName(prefix) + " = " + --negative + ";");
            } else {
                System.out.println("public static final int " + stateName(prefix) + " = " + ++positive + ";");
            }
        }
    }

    private void generateEntryCases() {
        final int len = entries.length();
        for (int i = 0; i < len; ++i) {
            char input = entries.charAt(i);
            System.out.println("case '" + input + "': return " + stateName(input) + ";");
        }
    }

    private void generateTransitionCases(boolean filterOnKeywords, String methodName, String tokenReturnValue) {
        ArrayList<String> leaves = new ArrayList<>();
        for (Map.Entry<String, String> entry : transitions.entrySet()) {
            String prefix = entry.getKey();
            String inputs = entry.getValue();
            if (isKeywordPrefix(prefix) == filterOnKeywords) {
                if (inputs.isEmpty()) {
                    leaves.add(prefix);
                } else {
                    generateTransitionCase(methodName, prefix, inputs);
                }
            }
        }
        for (String leaf : leaves) {
            System.out.println("case " + stateName(leaf) + ":");
        }
        System.out.println("return " + tokenReturnValue + ";");
    }

    private void generateTransitionCase(String methodName, String prefix, String inputs) {
        System.out.print("case " + stateName(prefix) + ": return " + methodName + "(");
        final int len = inputs.length();
        for (int i = 0; i < len; ++i) {
            char input = inputs.charAt(i);
            System.out.print("'" + input + "', " + stateName(prefix + input) + ", ");
        }
        System.out.println("input);");
    }

    private boolean isKeywordPrefix(String prefix) {
        return stateName(prefix.charAt(0)).length() == 1;
    }

    private static String stateName(String prefix) {
        StringBuilder stateName = new StringBuilder(stateName(prefix.charAt(0)));
        final int len = prefix.length();
        for (int i = 1; i < len; ++i) {
            String name = stateName(prefix.charAt(i));
            if (name.length() > 1) {
                stateName.append('_');
            }
            stateName.append(name);
        }
        return stateName.toString();
    }

    private static String stateName(char input) {
        return asciiNames[input - 32];
    }

    private static final String[] asciiNames = {
            "SPACE", "BANG", "QUOTE", "HASH", "DOLLAR", "PERCENT", "AMPERSAND", "APOSTROPHE",
            "OPEN_PAREN", "CLOSE_PAREN", "ASTERISK", "PLUS", "COMMA", "HYPHEN", "DOT", "SLASH",
            "ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE",
            "COLON", "SEMICOLON", "LESS", "EQUAL", "MORE", "QUESTION", "AT",
            "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
            "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
            "OPEN_BRACKET", "BACKSLASH", "CLOSE_BRACKET", "CARET", "UNDERSCORE", "GRAVE",
            "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
            "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
            "OPEN_BRACE", "BAR", "CLOSE_BRACE", "TILDE"
    };
}
